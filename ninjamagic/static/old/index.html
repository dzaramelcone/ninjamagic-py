<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>MUD Prototype</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="/static/xterm.css" />
  <script src="/static/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-webgl@0.18.0/lib/addon-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script src="/static/world-map.js"></script>
  <script src="/static/colors.js"></script>
  <style>
    :root {
      /* ─── Material-3 palette ───────────────────────── */
      --bg: #1B1E26;
      --surface: #1C1F27;
      --on-surface: #ECE6F0;
      --primary: #7DD3FC;
      --danger: #F38BA8;

      /* 16-colour ANSI map */
      --ansi-black: var(--bg);
      --ansi-red: var(--danger);
      --ansi-green: #8BD5A1;
      --ansi-yellow: #F9E2AF;
      --ansi-blue: var(--primary);
      --ansi-magenta: #D0A8FF;
      --ansi-cyan: #94E2D5;
      --ansi-white: var(--on-surface);
      --ansi-bright-black: #2A2E37;
      --ansi-bright-red: #F6A0B8;
      --ansi-bright-green: #A6E3B0;
      --ansi-bright-yellow: #FAF0BF;
      --ansi-bright-blue: #A5E4FF;
      --ansi-bright-magenta: #E1C2FF;
      --ansi-bright-cyan: #B0F1E4;
      --ansi-bright-white: #FFFFFF;

      --row-h: 22px;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--on-surface);
      font-family: 'IBM Plex Mono', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* ─── card ────────────────────────────────────────── */
    #card {
      position: relative;
      width: calc(50ch + 8px);
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 20px 24px;
      background: var(--surface);
      border-radius: 18px;
      overflow: hidden;
    }

    #mapBox {
      align-self: center;
      border-radius: 12px;
      overflow: hidden;
      z-index: 0;
    }

    #chat {
      width: 100%;
      height: calc(var(--row-h) * 8);
      /* lock in 8 rows */
      flex: 0 0 calc(var(--row-h) * 8);
      /* <- same number keeps card size fixed */
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      /* newest sticks to bottom      */
      overflow: hidden;
    }

    /* one <div class="msg"> per line (now variable height)  */
    .msg {
      margin: 2px 0;
      /* breathing room, no overlap   */
      white-space: pre-wrap;
      /* wrap but keep spaces         */
      word-break: break-word;
      /* break long words if needed   */
      font: 19px 'IBM Plex Mono', monospace;
      font-weight: 300;
      color: var(--primary);
      transition: opacity .4s;
    }

    /* ─── prompt ──────────────────────────────────────── */
    #prompt {
      width: 100%;
      padding-top: 8px;
      display: flex;
      align-items: center;
      border-top: 1px solid rgba(255, 255, 255, .07);
    }

    #cmd {
      flex: 1;
      border: none;
      outline: none;
      padding: 0;
      background: transparent;
      font: 19px 'IBM Plex Mono', monospace;
      font-weight: 300;
      color: var(--primary);
      caret-color: var(--primary);
    }

    /* hide native xterm caret */
    .xterm-cursor-layer {
      opacity: 0
    }
  </style>

</head>

<body>
  <div id="card">
    <div id="mapBox"></div>
    <div id="chat"></div>
    <div id="prompt"><input id="cmd" autocomplete="off"></div>
  </div>
  <script>

  const css = getComputedStyle(document.documentElement);
  const cssVar = (name) => css.getPropertyValue(name).trim();
  const ansi = (n) => cssVar(`--ansi-${n}`);
  const SURFACE_RGB = hex2rgb(cssVar("--surface"));
  const theme = {
    background: cssVar("--surface"),
    foreground: cssVar("--on-surface"),
    cursor: cssVar("--primary"),

    black: ansi("black"),
    red: ansi("red"),
    green: ansi("green"),
    yellow: ansi("yellow"),
    blue: ansi("blue"),
    magenta: ansi("magenta"),
    cyan: ansi("cyan"),
    white: ansi("white"),
    brightBlack: ansi("bright-black"),
    brightRed: ansi("bright-red"),
    brightGreen: ansi("bright-green"),
    brightYellow: ansi("bright-yellow"),
    brightBlue: ansi("bright-blue"),
    brightMagenta: ansi("bright-magenta"),
    brightCyan: ansi("bright-cyan"),
    brightWhite: ansi("bright-white"),
  };


    /*--------------------------------------------------
    2. Layer buffers
    --------------------------------------------------*/
    const worldMaps = new WorldMaps();
    const COLS = 13, ROWS = 13;
    const Player = { map_id: 1, x: 1, y: 1 };

    const GameState = {
        CONNECTING: 'CONNECTING',
        LOADING_MAP: 'LOADING_MAP',
        READY: 'READY',
        DISCONNECTED: 'DISCONNECTED',
    };
    let currentGameState = GameState.CONNECTING;
    function viewOriginFromPlayer() {
      // Center the camera on the player's position.
      // The rendering loop will handle toroidal wrapping, so no clamping is needed.
      const left = Player.x - Math.floor(COLS / 2);
      const top = Player.y - Math.floor(ROWS / 2);
      return { left, top };
    }
    /*--------------------------------------------------
      5. Per-cell composition
    --------------------------------------------------*/
    function composeFrame(term) {
      // Determine the top-left corner of the camera viewport
      const { left: camLeft, top: camTop } = viewOriginFromPlayer();
      let out = '\x1b[H'; // ANSI escape code to move cursor to home (top-left)

      // Loop through each cell of the terminal screen (view port)
      for (let vy = 0; vy < ROWS; vy++) {
          const worldY = camTop + vy;
          for (let vx = 0; vx < COLS; vx++) {
              const worldX = camLeft + vx;
              const tileId = worldMaps.getTileAt(Player.map_id, worldX, worldY);
              if (tileId === null || tileId === undefined) {
                  out += ' ';
                  continue;
              }
              
              const legendEntry = worldMaps.getLegendEntry(Player.map_id, tileId);
              if (!legendEntry) {
                  out += '?'; 
                  continue;
              }

              const glyph = legendEntry.char;
              const hsvColor = legendEntry.color;
              const baseRgb = hsv2rgb(hsvColor.h, hsvColor.s, hsvColor.v);

              // apply lighting/effects
              // 0 returns the base color
              const [r, g, b] = lerpHSV_rgb(baseRgb, SURFACE_RGB, 0);
              out += `\x1b[38;2;${r};${g};${b}m${glyph}`;
          }
          if (vy < ROWS - 1) out += '\r\n';
      }
      term.write(out + '\x1b[0m');
    }
    /*--------------------------------------------------
      7. Boot xterm
    --------------------------------------------------*/


    const term = new Terminal({
      rows: ROWS,
      cols: COLS,
      allowProposedApi: true,
      fontFamily: "'JetBrains Mono', monospace",
      fontSize: 32,
      letterSpacing: 20,
      theme
    });

    const webgl = new WebglAddon.WebglAddon();
    term.loadAddon(webgl);
    term.open(document.getElementById('mapBox'));

    /*--------------------------------------------------
      8. Main loop
    --------------------------------------------------*/
    const CYCLE_MS = 30_000;
    function tick() {
      const t = (performance.now() % CYCLE_MS) / CYCLE_MS;
      const { bg, surface, onSurface, primary } = paletteAt(t);
      document.documentElement.style.setProperty('--bg', int2hex(bg));
      document.documentElement.style.setProperty('--surface', int2hex(surface));
      document.documentElement.style.setProperty('--on-surface', int2hex(onSurface));
      document.documentElement.style.setProperty('--primary', int2hex(primary));
      switch (currentGameState) {
          case GameState.READY:
              composeFrame(term);
              break;

          case GameState.CONNECTING:
              term.write("\x1b[H\x1b[2JConnecting...");
              break;

          case GameState.LOADING_MAP:
              term.write("\x1b[H\x1b[2JLoading map data...");
              break;
          
          case GameState.DISCONNECTED:
              term.write("\x1b[H\x1b[2JConnection lost. Please refresh.");
              return;
      }
      requestAnimationFrame(tick);
    }
    tick();
    /*--------------------------------------------------
    chat initialisation (alignment & fade)
    --------------------------------------------------*/
    const chat = document.getElementById('chat');
    const cmd = document.getElementById('cmd');
    cmd.focus();

    function postLine(text) {
      const div = document.createElement('div');
      div.className = 'msg';
      div.textContent = text;
      chat.appendChild(div);

      /* keep only the newest 8 */
      while (chat.children.length > 8) chat.removeChild(chat.firstChild);

      /* exponential fade: 1.00, 0.55, 0.30 … bottom → top */
      [...chat.children].reverse().forEach((el, i) => {
        el.style.opacity = Math.max(0.07, Math.pow(0.55, i));
      });
    }
    const url = new URL("/ws", location.href);
    url.protocol = url.protocol.replace("http", "ws");
    const ws = new WebSocket(url.toString());
    const jsonHandlers = {
      m: (payload) => postLine(payload),
      l: (payload) => worldMaps.handleLegend(payload),
      p: ([map_id, x, y]) => { Player.map_id = map_id, Player.x = x; Player.y = y; },
    };

    ws.addEventListener("open", () => {
      postLine("*** connected ***");
      currentGameState = GameState.LOADING_MAP; 

    });
    ws.addEventListener("message", ev => {
      if (ev.data instanceof Blob) {
        ev.data.arrayBuffer().then(buffer => {
          worldMaps.handleTile(buffer);
          if (currentGameState === GameState.LOADING_MAP) {
            currentGameState = GameState.READY;
          }
        }).catch(error => console.error("Error reading Blob data:", error));
      }
      else
      {
        for (const item of JSON.parse(ev.data)) {
          for (const key in item) {
            const handler = jsonHandlers[key];
            if (handler) {
              handler(item[key]);
            }
            else {
              console.warn("No handler for message key: ${key}");
            }
          }
        }
      }
    });

    ws.addEventListener("close", ev => {
      postLine("*** disconnected (" + ev.code + ") ***");
      currentGameState = GameState.DISCONNECTED;
    });

    ws.addEventListener("error", () => {
      postLine("*** websocket error ***");
    });

    cmd.addEventListener('keydown', e => {
      if (e.key === 'Enter' && cmd.value.trim()) {
        postLine(cmd.value);
        ws.send(cmd.value);
        cmd.value = '';
      }
    });

  </script>
</body>
</html>
