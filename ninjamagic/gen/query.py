# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: query.sql
import pydantic
from typing import AsyncIterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from ninjamagic.gen import models


CREATE_CHARACTER = """-- name: create_character \\:one
INSERT INTO characters (owner_id, name, pronoun) VALUES (:p1, :p2, :p3) RETURNING id, owner_id, name, pronoun, glyph, glyph_h, glyph_s, glyph_v, map_id, x, y, health, stress, aggravated_stress, stance, condition, grace, grit, wit, created_at, updated_at
"""


DELETE_CHARACTER = """-- name: delete_character \\:exec
DELETE FROM characters WHERE id = :p1
"""


GET_CHARACTER = """-- name: get_character \\:one
SELECT id, owner_id, name, pronoun, glyph, glyph_h, glyph_s, glyph_v, map_id, x, y, health, stress, aggravated_stress, stance, condition, grace, grit, wit, created_at, updated_at FROM characters c WHERE c.owner_id = :p1
"""


GET_CHARACTER_BRIEF = """-- name: get_character_brief \\:one

SELECT id, owner_id, name FROM characters WHERE owner_id = :p1
"""


class GetCharacterBriefRow(pydantic.BaseModel):
    id: int
    owner_id: int
    name: str


GET_SKILLS_FOR_CHARACTER = """-- name: get_skills_for_character \\:many

SELECT id, char_id, name, rank, tnl, pending FROM skills WHERE char_id = :p1
"""


UPDATE_CHARACTER = """-- name: update_character \\:exec
UPDATE characters
SET
  glyph = coalesce(:p2, glyph),
  glyph_h = coalesce(:p3, glyph_h),
  glyph_v = coalesce(:p4, glyph_v),
  glyph_s = coalesce(:p5, glyph_s),
  pronoun = coalesce(:p6, pronoun),
  map_id = coalesce(:p7, map_id),
  x = coalesce(:p8, x),
  y = coalesce(:p9, y),
  health = coalesce(:p10, health),
  stress = coalesce(:p11, stress),
  aggravated_stress = coalesce(:p12, aggravated_stress),
  stance = coalesce(:p13, stance),
  condition = coalesce(:p14, condition),
  grace = coalesce(:p15, grace),
  grit = coalesce(:p16, grit),
  wit = coalesce(:p17, wit),
  updated_at = now()
WHERE id = :p1
"""


class UpdateCharacterParams(pydantic.BaseModel):
    id: int
    glyph: Optional[str]
    glyph_h: Optional[float]
    glyph_v: Optional[float]
    glyph_s: Optional[float]
    pronoun: Optional[models.Pronoun]
    map_id: Optional[int]
    x: Optional[int]
    y: Optional[int]
    health: Optional[float]
    stress: Optional[float]
    aggravated_stress: Optional[float]
    stance: Optional[models.Stance]
    condition: Optional[models.Condition]
    grace: Optional[int]
    grit: Optional[int]
    wit: Optional[int]


UPSERT_IDENTITY = """-- name: upsert_identity \\:one

INSERT INTO accounts (owner_id, provider, subject, email, created_at, last_login_at)
VALUES (DEFAULT, :p1, :p2, :p3, now(), now())
ON CONFLICT (provider, subject) DO UPDATE
  SET email = EXCLUDED.email,
      last_login_at = EXCLUDED.last_login_at
RETURNING owner_id
"""


UPSERT_SKILL = """-- name: upsert_skill \\:exec
INSERT INTO skills (char_id, name, rank, tnl, pending)
VALUES (:p1, :p2, :p3, :p4, :p5)
ON CONFLICT (char_id, name) DO UPDATE
SET rank = EXCLUDED.rank,
    tnl = EXCLUDED.tnl,
    pending = EXCLUDED.pending
"""


UPSERT_SKILLS = """-- name: upsert_skills \\:exec
INSERT INTO skills (char_id, name, rank, tnl, pending)
SELECT
  :p1,
  unnest(:p2\\:\\:text[]),
  unnest(:p3\\:\\:bigint[]),
  unnest(:p4\\:\\:real[]),
  unnest(:p5\\:\\:real[])
ON CONFLICT (char_id, name) DO UPDATE
SET rank = EXCLUDED.rank,
    tnl = EXCLUDED.tnl,
    pending = EXCLUDED.pending
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_character(self, *, owner_id: int, name: str, pronoun: models.Pronoun) -> Optional[models.Character]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_CHARACTER), {"p1": owner_id, "p2": name, "p3": pronoun})).first()
        if row is None:
            return None
        return models.Character(
            id=row[0],
            owner_id=row[1],
            name=row[2],
            pronoun=row[3],
            glyph=row[4],
            glyph_h=row[5],
            glyph_s=row[6],
            glyph_v=row[7],
            map_id=row[8],
            x=row[9],
            y=row[10],
            health=row[11],
            stress=row[12],
            aggravated_stress=row[13],
            stance=row[14],
            condition=row[15],
            grace=row[16],
            grit=row[17],
            wit=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def delete_character(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_CHARACTER), {"p1": id})

    async def get_character(self, *, owner_id: int) -> Optional[models.Character]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CHARACTER), {"p1": owner_id})).first()
        if row is None:
            return None
        return models.Character(
            id=row[0],
            owner_id=row[1],
            name=row[2],
            pronoun=row[3],
            glyph=row[4],
            glyph_h=row[5],
            glyph_s=row[6],
            glyph_v=row[7],
            map_id=row[8],
            x=row[9],
            y=row[10],
            health=row[11],
            stress=row[12],
            aggravated_stress=row[13],
            stance=row[14],
            condition=row[15],
            grace=row[16],
            grit=row[17],
            wit=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def get_character_brief(self, *, owner_id: int) -> Optional[GetCharacterBriefRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CHARACTER_BRIEF), {"p1": owner_id})).first()
        if row is None:
            return None
        return GetCharacterBriefRow(
            id=row[0],
            owner_id=row[1],
            name=row[2],
        )

    async def get_skills_for_character(self, *, char_id: int) -> AsyncIterator[models.Skill]:
        result = await self._conn.stream(sqlalchemy.text(GET_SKILLS_FOR_CHARACTER), {"p1": char_id})
        async for row in result:
            yield models.Skill(
                id=row[0],
                char_id=row[1],
                name=row[2],
                rank=row[3],
                tnl=row[4],
                pending=row[5],
            )

    async def update_character(self, arg: UpdateCharacterParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_CHARACTER), {
            "p1": arg.id,
            "p2": arg.glyph,
            "p3": arg.glyph_h,
            "p4": arg.glyph_v,
            "p5": arg.glyph_s,
            "p6": arg.pronoun,
            "p7": arg.map_id,
            "p8": arg.x,
            "p9": arg.y,
            "p10": arg.health,
            "p11": arg.stress,
            "p12": arg.aggravated_stress,
            "p13": arg.stance,
            "p14": arg.condition,
            "p15": arg.grace,
            "p16": arg.grit,
            "p17": arg.wit,
        })

    async def upsert_identity(self, *, provider: models.OauthProvider, subject: str, email: str) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_IDENTITY), {"p1": provider, "p2": subject, "p3": email})).first()
        if row is None:
            return None
        return row[0]

    async def upsert_skill(self, *, char_id: int, name: str, rank: int, tnl: float, pending: float) -> None:
        await self._conn.execute(sqlalchemy.text(UPSERT_SKILL), {
            "p1": char_id,
            "p2": name,
            "p3": rank,
            "p4": tnl,
            "p5": pending,
        })

    async def upsert_skills(self, *, char_id: int, names: List[str], ranks: List[int], tnls: List[float], pendings: List[float]) -> None:
        await self._conn.execute(sqlalchemy.text(UPSERT_SKILLS), {
            "p1": char_id,
            "p2": names,
            "p3": ranks,
            "p4": tnls,
            "p5": pendings,
        })
