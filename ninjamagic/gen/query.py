# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: query.sql
import pydantic
from typing import Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from ninjamagic.gen import models


CREATE_CHARACTER = """-- name: create_character \\:one
INSERT INTO characters (owner_id, name, pronoun) VALUES (:p1, :p2, :p3) RETURNING id, owner_id, name, pronoun, glyph, map_id, x, y, health, stress, aggravated_stress, stance, condition, grace, grit, wit, rank_evasion, tnl_evasion, rank_martial_arts, tnl_martial_arts, created_at, updated_at
"""


DELETE_CHARACTER = """-- name: delete_character \\:exec
DELETE FROM characters WHERE id = :p1
"""


GET_CHARACTER = """-- name: get_character \\:one
SELECT id, owner_id, name, pronoun, glyph, map_id, x, y, health, stress, aggravated_stress, stance, condition, grace, grit, wit, rank_evasion, tnl_evasion, rank_martial_arts, tnl_martial_arts, created_at, updated_at FROM characters c WHERE c.owner_id = :p1
"""


GET_CHARACTER_BRIEF = """-- name: get_character_brief \\:one

SELECT id, owner_id, name FROM characters WHERE owner_id = :p1
"""


class GetCharacterBriefRow(pydantic.BaseModel):
    id: int
    owner_id: int
    name: str


UPDATE_CHARACTER = """-- name: update_character \\:exec
UPDATE characters
SET
  glyph = coalesce(:p2, glyph),
  pronoun = coalesce(:p3, pronoun),
  map_id = coalesce(:p4, map_id),
  x = coalesce(:p5, x),
  y = coalesce(:p6, y),
  health = coalesce(:p7, health),
  stress = coalesce(:p8, stress),
  aggravated_stress = coalesce(:p9, aggravated_stress),
  stance = coalesce(:p10, stance),
  condition = coalesce(:p11, condition),
  grace = coalesce(:p12, grace),
  grit = coalesce(:p13, grit),
  wit = coalesce(:p14, wit),
  rank_martial_arts = coalesce(:p15, rank_martial_arts),
  tnl_martial_arts = coalesce(:p16, tnl_martial_arts),
  rank_evasion = coalesce(:p17, rank_evasion),
  tnl_evasion = coalesce(:p18, tnl_evasion),
  updated_at = now()
WHERE id = :p1
"""


class UpdateCharacterParams(pydantic.BaseModel):
    id: int
    glyph: Optional[str]
    pronoun: Optional[models.Pronoun]
    map_id: Optional[int]
    x: Optional[int]
    y: Optional[int]
    health: Optional[float]
    stress: Optional[float]
    aggravated_stress: Optional[float]
    stance: Optional[models.Stance]
    condition: Optional[models.Condition]
    grace: Optional[int]
    grit: Optional[int]
    wit: Optional[int]
    rank_martial_arts: Optional[int]
    tnl_martial_arts: Optional[float]
    rank_evasion: Optional[int]
    tnl_evasion: Optional[float]


UPSERT_IDENTITY = """-- name: upsert_identity \\:one

INSERT INTO accounts (owner_id, provider, subject, email, created_at, last_login_at)
VALUES (DEFAULT, :p1, :p2, :p3, now(), now())
ON CONFLICT (provider, subject) DO UPDATE
  SET email = EXCLUDED.email,
      last_login_at = EXCLUDED.last_login_at
RETURNING owner_id
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_character(self, *, owner_id: int, name: str, pronoun: models.Pronoun) -> Optional[models.Character]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_CHARACTER), {"p1": owner_id, "p2": name, "p3": pronoun})).first()
        if row is None:
            return None
        return models.Character(
            id=row[0],
            owner_id=row[1],
            name=row[2],
            pronoun=row[3],
            glyph=row[4],
            map_id=row[5],
            x=row[6],
            y=row[7],
            health=row[8],
            stress=row[9],
            aggravated_stress=row[10],
            stance=row[11],
            condition=row[12],
            grace=row[13],
            grit=row[14],
            wit=row[15],
            rank_evasion=row[16],
            tnl_evasion=row[17],
            rank_martial_arts=row[18],
            tnl_martial_arts=row[19],
            created_at=row[20],
            updated_at=row[21],
        )

    async def delete_character(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_CHARACTER), {"p1": id})

    async def get_character(self, *, owner_id: int) -> Optional[models.Character]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CHARACTER), {"p1": owner_id})).first()
        if row is None:
            return None
        return models.Character(
            id=row[0],
            owner_id=row[1],
            name=row[2],
            pronoun=row[3],
            glyph=row[4],
            map_id=row[5],
            x=row[6],
            y=row[7],
            health=row[8],
            stress=row[9],
            aggravated_stress=row[10],
            stance=row[11],
            condition=row[12],
            grace=row[13],
            grit=row[14],
            wit=row[15],
            rank_evasion=row[16],
            tnl_evasion=row[17],
            rank_martial_arts=row[18],
            tnl_martial_arts=row[19],
            created_at=row[20],
            updated_at=row[21],
        )

    async def get_character_brief(self, *, owner_id: int) -> Optional[GetCharacterBriefRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CHARACTER_BRIEF), {"p1": owner_id})).first()
        if row is None:
            return None
        return GetCharacterBriefRow(
            id=row[0],
            owner_id=row[1],
            name=row[2],
        )

    async def update_character(self, arg: UpdateCharacterParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_CHARACTER), {
            "p1": arg.id,
            "p2": arg.glyph,
            "p3": arg.pronoun,
            "p4": arg.map_id,
            "p5": arg.x,
            "p6": arg.y,
            "p7": arg.health,
            "p8": arg.stress,
            "p9": arg.aggravated_stress,
            "p10": arg.stance,
            "p11": arg.condition,
            "p12": arg.grace,
            "p13": arg.grit,
            "p14": arg.wit,
            "p15": arg.rank_martial_arts,
            "p16": arg.tnl_martial_arts,
            "p17": arg.rank_evasion,
            "p18": arg.tnl_evasion,
        })

    async def upsert_identity(self, *, provider: models.OauthProvider, subject: str, email: str) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_IDENTITY), {"p1": provider, "p2": subject, "p3": email})).first()
        if row is None:
            return None
        return row[0]
