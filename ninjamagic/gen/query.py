# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: query.sql
from typing import AsyncIterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from ninjamagic.gen import models

CREATE_CHARACTER = """-- name: create_character \\:one
INSERT INTO characters (owner_id, name) VALUES (:p1, :p2) RETURNING id, owner_id, name, created_at
"""


DELETE_CHARACTER = """-- name: delete_character \\:exec
DELETE FROM characters WHERE id = :p1
"""


GET_CHARACTERS = """-- name: get_characters \\:many

SELECT id, owner_id, name, created_at FROM characters WHERE owner_id = :p1 ORDER BY created_at DESC
"""


GET_SKILLS_BY_CHARACTER = """-- name: get_skills_by_character \\:many

SELECT id, char_id, name, experience, pending FROM skills WHERE char_id = :p1
"""


UPSERT_IDENTITY = """-- name: upsert_identity \\:one

INSERT INTO accounts (owner_id, provider, subject, email, created_at, last_login_at)
VALUES (DEFAULT, :p1, :p2, :p3, now(), now())
ON CONFLICT (provider, subject) DO UPDATE
  SET email = EXCLUDED.email,
      last_login_at = EXCLUDED.last_login_at
RETURNING owner_id
"""


UPSERT_SKILLS = """-- name: upsert_skills \\:exec
INSERT INTO skills (char_id, name, experience, pending)
SELECT
  :p1\\:\\:bigint,
  n.name,
  e.experience,
  p.pending
FROM unnest(:p2\\:\\:citext[])  WITH ORDINALITY AS n(name, i)
JOIN unnest(:p3\\:\\:bigint[])  WITH ORDINALITY AS e(experience, i) USING (i)
JOIN unnest(:p4\\:\\:bigint[])  WITH ORDINALITY AS p(pending, i)    USING (i)
ON CONFLICT (char_id, name) DO UPDATE
SET experience = EXCLUDED.experience,
    pending    = EXCLUDED.pending
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_character(
        self, *, owner_id: int, name: str
    ) -> Optional[models.Character]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_CHARACTER), {"p1": owner_id, "p2": name}
            )
        ).first()
        if row is None:
            return None
        return models.Character(
            id=row[0],
            owner_id=row[1],
            name=row[2],
            created_at=row[3],
        )

    async def delete_character(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_CHARACTER), {"p1": id})

    async def get_characters(self, *, owner_id: int) -> AsyncIterator[models.Character]:
        result = await self._conn.stream(
            sqlalchemy.text(GET_CHARACTERS), {"p1": owner_id}
        )
        async for row in result:
            yield models.Character(
                id=row[0],
                owner_id=row[1],
                name=row[2],
                created_at=row[3],
            )

    async def get_skills_by_character(
        self, *, char_id: int
    ) -> AsyncIterator[models.Skill]:
        result = await self._conn.stream(
            sqlalchemy.text(GET_SKILLS_BY_CHARACTER), {"p1": char_id}
        )
        async for row in result:
            yield models.Skill(
                id=row[0],
                char_id=row[1],
                name=row[2],
                experience=row[3],
                pending=row[4],
            )

    async def upsert_identity(
        self, *, provider: models.OauthProvider, subject: str, email: str
    ) -> Optional[int]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPSERT_IDENTITY),
                {"p1": provider, "p2": subject, "p3": email},
            )
        ).first()
        if row is None:
            return None
        return row[0]

    async def upsert_skills(
        self,
        *,
        dollar_1: int,
        dollar_2: List[str],
        dollar_3: List[int],
        dollar_4: List[int],
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(UPSERT_SKILLS),
            {
                "p1": dollar_1,
                "p2": dollar_2,
                "p3": dollar_3,
                "p4": dollar_4,
            },
        )
