// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "messages.proto" (package "ninjamagic", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ninjamagic.Msg
 */
export interface Msg {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Pos
 */
export interface Pos {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    mapId: number;
    /**
     * @generated from protobuf field: int32 x = 3
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 4
     */
    y: number;
}
/**
 * @generated from protobuf message ninjamagic.Chip
 */
export interface Chip {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    mapId: number;
    /**
     * @generated from protobuf field: uint32 glyph = 3
     */
    glyph: number;
    /**
     * @generated from protobuf field: float h = 4
     */
    h: number;
    /**
     * @generated from protobuf field: float s = 5
     */
    s: number;
    /**
     * @generated from protobuf field: float v = 6
     */
    v: number;
    /**
     * @generated from protobuf field: float a = 7
     */
    a: number;
}
/**
 * @generated from protobuf message ninjamagic.Tile
 */
export interface Tile {
    /**
     * @generated from protobuf field: uint32 map_id = 1
     */
    mapId: number;
    /**
     * @generated from protobuf field: int32 top = 2
     */
    top: number;
    /**
     * @generated from protobuf field: int32 left = 3
     */
    left: number;
    /**
     * @generated from protobuf field: bytes data = 4
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message ninjamagic.Gas
 */
export interface Gas {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    mapId: number;
    /**
     * @generated from protobuf field: int32 x = 3
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 4
     */
    y: number;
    /**
     * @generated from protobuf field: float v = 5
     */
    v: number;
}
/**
 * @generated from protobuf message ninjamagic.Glyph
 */
export interface Glyph {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string glyph = 2
     */
    glyph: string;
}
/**
 * @generated from protobuf message ninjamagic.Noun
 */
export interface Noun {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Health
 */
export interface Health {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: float pct = 2
     */
    pct: number;
}
/**
 * @generated from protobuf message ninjamagic.Stance
 */
export interface Stance {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * A wrapper that can contain any of our specific message types.
 *
 * @generated from protobuf message ninjamagic.Kind
 */
export interface Kind {
    /**
     * @generated from protobuf oneof: body
     */
    body: {
        oneofKind: "msg";
        /**
         * @generated from protobuf field: ninjamagic.Msg msg = 1
         */
        msg: Msg;
    } | {
        oneofKind: "pos";
        /**
         * @generated from protobuf field: ninjamagic.Pos pos = 2
         */
        pos: Pos;
    } | {
        oneofKind: "chip";
        /**
         * @generated from protobuf field: ninjamagic.Chip chip = 3
         */
        chip: Chip;
    } | {
        oneofKind: "tile";
        /**
         * @generated from protobuf field: ninjamagic.Tile tile = 4
         */
        tile: Tile;
    } | {
        oneofKind: "gas";
        /**
         * @generated from protobuf field: ninjamagic.Gas gas = 5
         */
        gas: Gas;
    } | {
        oneofKind: "glyph";
        /**
         * @generated from protobuf field: ninjamagic.Glyph glyph = 6
         */
        glyph: Glyph;
    } | {
        oneofKind: "noun";
        /**
         * @generated from protobuf field: ninjamagic.Noun noun = 7
         */
        noun: Noun;
    } | {
        oneofKind: "health";
        /**
         * @generated from protobuf field: ninjamagic.Health health = 8
         */
        health: Health;
    } | {
        oneofKind: "stance";
        /**
         * @generated from protobuf field: ninjamagic.Stance stance = 9
         */
        stance: Stance;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The root message, which is a list of individual messages.
 *
 * @generated from protobuf message ninjamagic.Packet
 */
export interface Packet {
    /**
     * @generated from protobuf field: repeated ninjamagic.Kind envelope = 1
     */
    envelope: Kind[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Msg$Type extends MessageType<Msg> {
    constructor() {
        super("ninjamagic.Msg", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Msg>): Msg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Msg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Msg): Msg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Msg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Msg
 */
export const Msg = new Msg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pos$Type extends MessageType<Pos> {
    constructor() {
        super("ninjamagic.Pos", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Pos>): Pos {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.mapId = 0;
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Pos>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pos): Pos {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.mapId = reader.uint32();
                    break;
                case /* int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 4:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pos, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.mapId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.mapId);
        /* int32 x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* int32 y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Pos
 */
export const Pos = new Pos$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chip$Type extends MessageType<Chip> {
    constructor() {
        super("ninjamagic.Chip", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "glyph", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "h", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "a", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Chip>): Chip {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.mapId = 0;
        message.glyph = 0;
        message.h = 0;
        message.s = 0;
        message.v = 0;
        message.a = 0;
        if (value !== undefined)
            reflectionMergePartial<Chip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chip): Chip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.mapId = reader.uint32();
                    break;
                case /* uint32 glyph */ 3:
                    message.glyph = reader.uint32();
                    break;
                case /* float h */ 4:
                    message.h = reader.float();
                    break;
                case /* float s */ 5:
                    message.s = reader.float();
                    break;
                case /* float v */ 6:
                    message.v = reader.float();
                    break;
                case /* float a */ 7:
                    message.a = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.mapId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.mapId);
        /* uint32 glyph = 3; */
        if (message.glyph !== 0)
            writer.tag(3, WireType.Varint).uint32(message.glyph);
        /* float h = 4; */
        if (message.h !== 0)
            writer.tag(4, WireType.Bit32).float(message.h);
        /* float s = 5; */
        if (message.s !== 0)
            writer.tag(5, WireType.Bit32).float(message.s);
        /* float v = 6; */
        if (message.v !== 0)
            writer.tag(6, WireType.Bit32).float(message.v);
        /* float a = 7; */
        if (message.a !== 0)
            writer.tag(7, WireType.Bit32).float(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Chip
 */
export const Chip = new Chip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tile$Type extends MessageType<Tile> {
    constructor() {
        super("ninjamagic.Tile", [
            { no: 1, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "top", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "left", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Tile>): Tile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapId = 0;
        message.top = 0;
        message.left = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Tile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tile): Tile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 map_id */ 1:
                    message.mapId = reader.uint32();
                    break;
                case /* int32 top */ 2:
                    message.top = reader.int32();
                    break;
                case /* int32 left */ 3:
                    message.left = reader.int32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 map_id = 1; */
        if (message.mapId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.mapId);
        /* int32 top = 2; */
        if (message.top !== 0)
            writer.tag(2, WireType.Varint).int32(message.top);
        /* int32 left = 3; */
        if (message.left !== 0)
            writer.tag(3, WireType.Varint).int32(message.left);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Tile
 */
export const Tile = new Tile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gas$Type extends MessageType<Gas> {
    constructor() {
        super("ninjamagic.Gas", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Gas>): Gas {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.mapId = 0;
        message.x = 0;
        message.y = 0;
        message.v = 0;
        if (value !== undefined)
            reflectionMergePartial<Gas>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gas): Gas {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.mapId = reader.uint32();
                    break;
                case /* int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 4:
                    message.y = reader.int32();
                    break;
                case /* float v */ 5:
                    message.v = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gas, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.mapId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.mapId);
        /* int32 x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* int32 y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).int32(message.y);
        /* float v = 5; */
        if (message.v !== 0)
            writer.tag(5, WireType.Bit32).float(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Gas
 */
export const Gas = new Gas$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Glyph$Type extends MessageType<Glyph> {
    constructor() {
        super("ninjamagic.Glyph", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "glyph", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Glyph>): Glyph {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.glyph = "";
        if (value !== undefined)
            reflectionMergePartial<Glyph>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Glyph): Glyph {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string glyph */ 2:
                    message.glyph = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Glyph, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string glyph = 2; */
        if (message.glyph !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.glyph);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Glyph
 */
export const Glyph = new Glyph$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Noun$Type extends MessageType<Noun> {
    constructor() {
        super("ninjamagic.Noun", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Noun>): Noun {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Noun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Noun): Noun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Noun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Noun
 */
export const Noun = new Noun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Health$Type extends MessageType<Health> {
    constructor() {
        super("ninjamagic.Health", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pct", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Health>): Health {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.pct = 0;
        if (value !== undefined)
            reflectionMergePartial<Health>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Health): Health {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* float pct */ 2:
                    message.pct = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Health, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* float pct = 2; */
        if (message.pct !== 0)
            writer.tag(2, WireType.Bit32).float(message.pct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Health
 */
export const Health = new Health$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stance$Type extends MessageType<Stance> {
    constructor() {
        super("ninjamagic.Stance", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Stance>): Stance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Stance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stance): Stance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Stance
 */
export const Stance = new Stance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Kind$Type extends MessageType<Kind> {
    constructor() {
        super("ninjamagic.Kind", [
            { no: 1, name: "msg", kind: "message", oneof: "body", T: () => Msg },
            { no: 2, name: "pos", kind: "message", oneof: "body", T: () => Pos },
            { no: 3, name: "chip", kind: "message", oneof: "body", T: () => Chip },
            { no: 4, name: "tile", kind: "message", oneof: "body", T: () => Tile },
            { no: 5, name: "gas", kind: "message", oneof: "body", T: () => Gas },
            { no: 6, name: "glyph", kind: "message", oneof: "body", T: () => Glyph },
            { no: 7, name: "noun", kind: "message", oneof: "body", T: () => Noun },
            { no: 8, name: "health", kind: "message", oneof: "body", T: () => Health },
            { no: 9, name: "stance", kind: "message", oneof: "body", T: () => Stance }
        ]);
    }
    create(value?: PartialMessage<Kind>): Kind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.body = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Kind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Kind): Kind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ninjamagic.Msg msg */ 1:
                    message.body = {
                        oneofKind: "msg",
                        msg: Msg.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).msg)
                    };
                    break;
                case /* ninjamagic.Pos pos */ 2:
                    message.body = {
                        oneofKind: "pos",
                        pos: Pos.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).pos)
                    };
                    break;
                case /* ninjamagic.Chip chip */ 3:
                    message.body = {
                        oneofKind: "chip",
                        chip: Chip.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).chip)
                    };
                    break;
                case /* ninjamagic.Tile tile */ 4:
                    message.body = {
                        oneofKind: "tile",
                        tile: Tile.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).tile)
                    };
                    break;
                case /* ninjamagic.Gas gas */ 5:
                    message.body = {
                        oneofKind: "gas",
                        gas: Gas.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).gas)
                    };
                    break;
                case /* ninjamagic.Glyph glyph */ 6:
                    message.body = {
                        oneofKind: "glyph",
                        glyph: Glyph.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).glyph)
                    };
                    break;
                case /* ninjamagic.Noun noun */ 7:
                    message.body = {
                        oneofKind: "noun",
                        noun: Noun.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).noun)
                    };
                    break;
                case /* ninjamagic.Health health */ 8:
                    message.body = {
                        oneofKind: "health",
                        health: Health.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).health)
                    };
                    break;
                case /* ninjamagic.Stance stance */ 9:
                    message.body = {
                        oneofKind: "stance",
                        stance: Stance.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).stance)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Kind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ninjamagic.Msg msg = 1; */
        if (message.body.oneofKind === "msg")
            Msg.internalBinaryWrite(message.body.msg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Pos pos = 2; */
        if (message.body.oneofKind === "pos")
            Pos.internalBinaryWrite(message.body.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Chip chip = 3; */
        if (message.body.oneofKind === "chip")
            Chip.internalBinaryWrite(message.body.chip, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Tile tile = 4; */
        if (message.body.oneofKind === "tile")
            Tile.internalBinaryWrite(message.body.tile, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Gas gas = 5; */
        if (message.body.oneofKind === "gas")
            Gas.internalBinaryWrite(message.body.gas, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Glyph glyph = 6; */
        if (message.body.oneofKind === "glyph")
            Glyph.internalBinaryWrite(message.body.glyph, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Noun noun = 7; */
        if (message.body.oneofKind === "noun")
            Noun.internalBinaryWrite(message.body.noun, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Health health = 8; */
        if (message.body.oneofKind === "health")
            Health.internalBinaryWrite(message.body.health, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Stance stance = 9; */
        if (message.body.oneofKind === "stance")
            Stance.internalBinaryWrite(message.body.stance, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Kind
 */
export const Kind = new Kind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Packet$Type extends MessageType<Packet> {
    constructor() {
        super("ninjamagic.Packet", [
            { no: 1, name: "envelope", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Kind }
        ]);
    }
    create(value?: PartialMessage<Packet>): Packet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.envelope = [];
        if (value !== undefined)
            reflectionMergePartial<Packet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Packet): Packet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ninjamagic.Kind envelope */ 1:
                    message.envelope.push(Kind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Packet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ninjamagic.Kind envelope = 1; */
        for (let i = 0; i < message.envelope.length; i++)
            Kind.internalBinaryWrite(message.envelope[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Packet
 */
export const Packet = new Packet$Type();
