// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "messages.proto" (package "ninjamagic", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ninjamagic.Msg
 */
export interface Msg {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Pos
 */
export interface Pos {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    mapId: number;
    /**
     * @generated from protobuf field: uint32 x = 3
     */
    x: number;
    /**
     * @generated from protobuf field: uint32 y = 4
     */
    y: number;
}
/**
 * @generated from protobuf message ninjamagic.Chip
 */
export interface Chip {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    mapId: number;
    /**
     * @generated from protobuf field: uint32 glyph = 3
     */
    glyph: number;
    /**
     * @generated from protobuf field: float h = 4
     */
    h: number;
    /**
     * @generated from protobuf field: float s = 5
     */
    s: number;
    /**
     * @generated from protobuf field: float v = 6
     */
    v: number;
    /**
     * @generated from protobuf field: float a = 7
     */
    a: number;
}
/**
 * @generated from protobuf message ninjamagic.Tile
 */
export interface Tile {
    /**
     * @generated from protobuf field: uint32 map_id = 1
     */
    mapId: number;
    /**
     * @generated from protobuf field: uint32 top = 2
     */
    top: number;
    /**
     * @generated from protobuf field: uint32 left = 3
     */
    left: number;
    /**
     * @generated from protobuf field: bytes data = 4
     */
    data: Uint8Array;
}
/**
 * A wrapper that can contain any of our specific message types.
 *
 * @generated from protobuf message ninjamagic.Kind
 */
export interface Kind {
    /**
     * @generated from protobuf oneof: body
     */
    body: {
        oneofKind: "msg";
        /**
         * @generated from protobuf field: ninjamagic.Msg msg = 1
         */
        msg: Msg;
    } | {
        oneofKind: "pos";
        /**
         * @generated from protobuf field: ninjamagic.Pos pos = 2
         */
        pos: Pos;
    } | {
        oneofKind: "chip";
        /**
         * @generated from protobuf field: ninjamagic.Chip chip = 3
         */
        chip: Chip;
    } | {
        oneofKind: "tile";
        /**
         * @generated from protobuf field: ninjamagic.Tile tile = 4
         */
        tile: Tile;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The root message, which is a list of individual messages.
 *
 * @generated from protobuf message ninjamagic.Packet
 */
export interface Packet {
    /**
     * @generated from protobuf field: repeated ninjamagic.Kind envelope = 1
     */
    envelope: Kind[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Msg$Type extends MessageType<Msg> {
    constructor() {
        super("ninjamagic.Msg", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Msg>): Msg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Msg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Msg): Msg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Msg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Msg
 */
export const Msg = new Msg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pos$Type extends MessageType<Pos> {
    constructor() {
        super("ninjamagic.Pos", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Pos>): Pos {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.mapId = 0;
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Pos>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pos): Pos {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.mapId = reader.uint32();
                    break;
                case /* uint32 x */ 3:
                    message.x = reader.uint32();
                    break;
                case /* uint32 y */ 4:
                    message.y = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pos, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.mapId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.mapId);
        /* uint32 x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).uint32(message.x);
        /* uint32 y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).uint32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Pos
 */
export const Pos = new Pos$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chip$Type extends MessageType<Chip> {
    constructor() {
        super("ninjamagic.Chip", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "glyph", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "h", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "a", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Chip>): Chip {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.mapId = 0;
        message.glyph = 0;
        message.h = 0;
        message.s = 0;
        message.v = 0;
        message.a = 0;
        if (value !== undefined)
            reflectionMergePartial<Chip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chip): Chip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.mapId = reader.uint32();
                    break;
                case /* uint32 glyph */ 3:
                    message.glyph = reader.uint32();
                    break;
                case /* float h */ 4:
                    message.h = reader.float();
                    break;
                case /* float s */ 5:
                    message.s = reader.float();
                    break;
                case /* float v */ 6:
                    message.v = reader.float();
                    break;
                case /* float a */ 7:
                    message.a = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.mapId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.mapId);
        /* uint32 glyph = 3; */
        if (message.glyph !== 0)
            writer.tag(3, WireType.Varint).uint32(message.glyph);
        /* float h = 4; */
        if (message.h !== 0)
            writer.tag(4, WireType.Bit32).float(message.h);
        /* float s = 5; */
        if (message.s !== 0)
            writer.tag(5, WireType.Bit32).float(message.s);
        /* float v = 6; */
        if (message.v !== 0)
            writer.tag(6, WireType.Bit32).float(message.v);
        /* float a = 7; */
        if (message.a !== 0)
            writer.tag(7, WireType.Bit32).float(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Chip
 */
export const Chip = new Chip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tile$Type extends MessageType<Tile> {
    constructor() {
        super("ninjamagic.Tile", [
            { no: 1, name: "map_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "top", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "left", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Tile>): Tile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapId = 0;
        message.top = 0;
        message.left = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Tile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tile): Tile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 map_id */ 1:
                    message.mapId = reader.uint32();
                    break;
                case /* uint32 top */ 2:
                    message.top = reader.uint32();
                    break;
                case /* uint32 left */ 3:
                    message.left = reader.uint32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 map_id = 1; */
        if (message.mapId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.mapId);
        /* uint32 top = 2; */
        if (message.top !== 0)
            writer.tag(2, WireType.Varint).uint32(message.top);
        /* uint32 left = 3; */
        if (message.left !== 0)
            writer.tag(3, WireType.Varint).uint32(message.left);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Tile
 */
export const Tile = new Tile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Kind$Type extends MessageType<Kind> {
    constructor() {
        super("ninjamagic.Kind", [
            { no: 1, name: "msg", kind: "message", oneof: "body", T: () => Msg },
            { no: 2, name: "pos", kind: "message", oneof: "body", T: () => Pos },
            { no: 3, name: "chip", kind: "message", oneof: "body", T: () => Chip },
            { no: 4, name: "tile", kind: "message", oneof: "body", T: () => Tile }
        ]);
    }
    create(value?: PartialMessage<Kind>): Kind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.body = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Kind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Kind): Kind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ninjamagic.Msg msg */ 1:
                    message.body = {
                        oneofKind: "msg",
                        msg: Msg.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).msg)
                    };
                    break;
                case /* ninjamagic.Pos pos */ 2:
                    message.body = {
                        oneofKind: "pos",
                        pos: Pos.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).pos)
                    };
                    break;
                case /* ninjamagic.Chip chip */ 3:
                    message.body = {
                        oneofKind: "chip",
                        chip: Chip.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).chip)
                    };
                    break;
                case /* ninjamagic.Tile tile */ 4:
                    message.body = {
                        oneofKind: "tile",
                        tile: Tile.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).tile)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Kind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ninjamagic.Msg msg = 1; */
        if (message.body.oneofKind === "msg")
            Msg.internalBinaryWrite(message.body.msg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Pos pos = 2; */
        if (message.body.oneofKind === "pos")
            Pos.internalBinaryWrite(message.body.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Chip chip = 3; */
        if (message.body.oneofKind === "chip")
            Chip.internalBinaryWrite(message.body.chip, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Tile tile = 4; */
        if (message.body.oneofKind === "tile")
            Tile.internalBinaryWrite(message.body.tile, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Kind
 */
export const Kind = new Kind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Packet$Type extends MessageType<Packet> {
    constructor() {
        super("ninjamagic.Packet", [
            { no: 1, name: "envelope", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Kind }
        ]);
    }
    create(value?: PartialMessage<Packet>): Packet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.envelope = [];
        if (value !== undefined)
            reflectionMergePartial<Packet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Packet): Packet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ninjamagic.Kind envelope */ 1:
                    message.envelope.push(Kind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Packet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ninjamagic.Kind envelope = 1; */
        for (let i = 0; i < message.envelope.length; i++)
            Kind.internalBinaryWrite(message.envelope[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Packet
 */
export const Packet = new Packet$Type();
