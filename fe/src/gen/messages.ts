// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "messages.proto" (package "ninjamagic", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ninjamagic.Msg
 */
export interface Msg {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Pos
 */
export interface Pos {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    map_id: number;
    /**
     * @generated from protobuf field: int32 x = 3
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 4
     */
    y: number;
    /**
     * @generated from protobuf field: bool quiet = 5
     */
    quiet: boolean;
}
/**
 * @generated from protobuf message ninjamagic.Chip
 */
export interface Chip {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    map_id: number;
    /**
     * @generated from protobuf field: uint32 glyph = 3
     */
    glyph: number;
    /**
     * @generated from protobuf field: float h = 4
     */
    h: number;
    /**
     * @generated from protobuf field: float s = 5
     */
    s: number;
    /**
     * @generated from protobuf field: float v = 6
     */
    v: number;
    /**
     * @generated from protobuf field: float a = 7
     */
    a: number;
}
/**
 * @generated from protobuf message ninjamagic.Tile
 */
export interface Tile {
    /**
     * @generated from protobuf field: uint32 map_id = 1
     */
    map_id: number;
    /**
     * @generated from protobuf field: int32 top = 2
     */
    top: number;
    /**
     * @generated from protobuf field: int32 left = 3
     */
    left: number;
    /**
     * @generated from protobuf field: bytes data = 4
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message ninjamagic.Gas
 */
export interface Gas {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 map_id = 2
     */
    map_id: number;
    /**
     * @generated from protobuf field: int32 x = 3
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 4
     */
    y: number;
    /**
     * @generated from protobuf field: float v = 5
     */
    v: number;
}
/**
 * @generated from protobuf message ninjamagic.Glyph
 */
export interface Glyph {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string glyph = 2
     */
    glyph: string;
    /**
     * @generated from protobuf field: float h = 3
     */
    h: number;
    /**
     * @generated from protobuf field: float s = 4
     */
    s: number;
    /**
     * @generated from protobuf field: float v = 5
     */
    v: number;
}
/**
 * @generated from protobuf message ninjamagic.Noun
 */
export interface Noun {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Health
 */
export interface Health {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: float pct = 2
     */
    pct: number;
    /**
     * @generated from protobuf field: float stress_pct = 3
     */
    stress_pct: number;
}
/**
 * @generated from protobuf message ninjamagic.Stance
 */
export interface Stance {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Condition
 */
export interface Condition {
    /**
     * @generated from protobuf field: uint32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message ninjamagic.Skill
 */
export interface Skill {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 rank = 2
     */
    rank: number;
    /**
     * @generated from protobuf field: float tnl = 3
     */
    tnl: number;
    /**
     * @generated from protobuf field: float pending = 4
     */
    pending: number;
}
/**
 * @generated from protobuf message ninjamagic.Datetime
 */
export interface Datetime {
    /**
     * @generated from protobuf field: uint64 seconds = 1
     */
    seconds: bigint;
}
/**
 * @generated from protobuf message ninjamagic.Prompt
 */
export interface Prompt {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
}
/**
 * A wrapper that can contain any of our specific message types.
 *
 * @generated from protobuf message ninjamagic.Kind
 */
export interface Kind {
    /**
     * @generated from protobuf oneof: body
     */
    body: {
        oneofKind: "msg";
        /**
         * @generated from protobuf field: ninjamagic.Msg msg = 1
         */
        msg: Msg;
    } | {
        oneofKind: "pos";
        /**
         * @generated from protobuf field: ninjamagic.Pos pos = 2
         */
        pos: Pos;
    } | {
        oneofKind: "chip";
        /**
         * @generated from protobuf field: ninjamagic.Chip chip = 3
         */
        chip: Chip;
    } | {
        oneofKind: "tile";
        /**
         * @generated from protobuf field: ninjamagic.Tile tile = 4
         */
        tile: Tile;
    } | {
        oneofKind: "gas";
        /**
         * @generated from protobuf field: ninjamagic.Gas gas = 5
         */
        gas: Gas;
    } | {
        oneofKind: "glyph";
        /**
         * @generated from protobuf field: ninjamagic.Glyph glyph = 6
         */
        glyph: Glyph;
    } | {
        oneofKind: "noun";
        /**
         * @generated from protobuf field: ninjamagic.Noun noun = 7
         */
        noun: Noun;
    } | {
        oneofKind: "health";
        /**
         * @generated from protobuf field: ninjamagic.Health health = 8
         */
        health: Health;
    } | {
        oneofKind: "stance";
        /**
         * @generated from protobuf field: ninjamagic.Stance stance = 9
         */
        stance: Stance;
    } | {
        oneofKind: "condition";
        /**
         * @generated from protobuf field: ninjamagic.Condition condition = 10
         */
        condition: Condition;
    } | {
        oneofKind: "skill";
        /**
         * @generated from protobuf field: ninjamagic.Skill skill = 11
         */
        skill: Skill;
    } | {
        oneofKind: "datetime";
        /**
         * @generated from protobuf field: ninjamagic.Datetime datetime = 12
         */
        datetime: Datetime;
    } | {
        oneofKind: "prompt";
        /**
         * @generated from protobuf field: ninjamagic.Prompt prompt = 13
         */
        prompt: Prompt;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The root message, which is a list of individual messages.
 *
 * @generated from protobuf message ninjamagic.Packet
 */
export interface Packet {
    /**
     * @generated from protobuf field: repeated ninjamagic.Kind envelope = 1
     */
    envelope: Kind[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Msg$Type extends MessageType<Msg> {
    constructor() {
        super("ninjamagic.Msg", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Msg>): Msg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Msg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Msg): Msg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Msg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Msg
 */
export const Msg = new Msg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pos$Type extends MessageType<Pos> {
    constructor() {
        super("ninjamagic.Pos", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", localName: "map_id", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "quiet", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Pos>): Pos {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.map_id = 0;
        message.x = 0;
        message.y = 0;
        message.quiet = false;
        if (value !== undefined)
            reflectionMergePartial<Pos>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pos): Pos {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.map_id = reader.uint32();
                    break;
                case /* int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 4:
                    message.y = reader.int32();
                    break;
                case /* bool quiet */ 5:
                    message.quiet = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pos, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.map_id !== 0)
            writer.tag(2, WireType.Varint).uint32(message.map_id);
        /* int32 x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* int32 y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).int32(message.y);
        /* bool quiet = 5; */
        if (message.quiet !== false)
            writer.tag(5, WireType.Varint).bool(message.quiet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Pos
 */
export const Pos = new Pos$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chip$Type extends MessageType<Chip> {
    constructor() {
        super("ninjamagic.Chip", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", localName: "map_id", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "glyph", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "h", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "a", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Chip>): Chip {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.map_id = 0;
        message.glyph = 0;
        message.h = 0;
        message.s = 0;
        message.v = 0;
        message.a = 0;
        if (value !== undefined)
            reflectionMergePartial<Chip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chip): Chip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.map_id = reader.uint32();
                    break;
                case /* uint32 glyph */ 3:
                    message.glyph = reader.uint32();
                    break;
                case /* float h */ 4:
                    message.h = reader.float();
                    break;
                case /* float s */ 5:
                    message.s = reader.float();
                    break;
                case /* float v */ 6:
                    message.v = reader.float();
                    break;
                case /* float a */ 7:
                    message.a = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.map_id !== 0)
            writer.tag(2, WireType.Varint).uint32(message.map_id);
        /* uint32 glyph = 3; */
        if (message.glyph !== 0)
            writer.tag(3, WireType.Varint).uint32(message.glyph);
        /* float h = 4; */
        if (message.h !== 0)
            writer.tag(4, WireType.Bit32).float(message.h);
        /* float s = 5; */
        if (message.s !== 0)
            writer.tag(5, WireType.Bit32).float(message.s);
        /* float v = 6; */
        if (message.v !== 0)
            writer.tag(6, WireType.Bit32).float(message.v);
        /* float a = 7; */
        if (message.a !== 0)
            writer.tag(7, WireType.Bit32).float(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Chip
 */
export const Chip = new Chip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tile$Type extends MessageType<Tile> {
    constructor() {
        super("ninjamagic.Tile", [
            { no: 1, name: "map_id", kind: "scalar", localName: "map_id", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "top", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "left", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Tile>): Tile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map_id = 0;
        message.top = 0;
        message.left = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Tile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tile): Tile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 map_id */ 1:
                    message.map_id = reader.uint32();
                    break;
                case /* int32 top */ 2:
                    message.top = reader.int32();
                    break;
                case /* int32 left */ 3:
                    message.left = reader.int32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 map_id = 1; */
        if (message.map_id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.map_id);
        /* int32 top = 2; */
        if (message.top !== 0)
            writer.tag(2, WireType.Varint).int32(message.top);
        /* int32 left = 3; */
        if (message.left !== 0)
            writer.tag(3, WireType.Varint).int32(message.left);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Tile
 */
export const Tile = new Tile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gas$Type extends MessageType<Gas> {
    constructor() {
        super("ninjamagic.Gas", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "map_id", kind: "scalar", localName: "map_id", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Gas>): Gas {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.map_id = 0;
        message.x = 0;
        message.y = 0;
        message.v = 0;
        if (value !== undefined)
            reflectionMergePartial<Gas>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gas): Gas {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 map_id */ 2:
                    message.map_id = reader.uint32();
                    break;
                case /* int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 4:
                    message.y = reader.int32();
                    break;
                case /* float v */ 5:
                    message.v = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gas, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 map_id = 2; */
        if (message.map_id !== 0)
            writer.tag(2, WireType.Varint).uint32(message.map_id);
        /* int32 x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* int32 y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).int32(message.y);
        /* float v = 5; */
        if (message.v !== 0)
            writer.tag(5, WireType.Bit32).float(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Gas
 */
export const Gas = new Gas$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Glyph$Type extends MessageType<Glyph> {
    constructor() {
        super("ninjamagic.Glyph", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "glyph", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "h", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Glyph>): Glyph {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.glyph = "";
        message.h = 0;
        message.s = 0;
        message.v = 0;
        if (value !== undefined)
            reflectionMergePartial<Glyph>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Glyph): Glyph {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string glyph */ 2:
                    message.glyph = reader.string();
                    break;
                case /* float h */ 3:
                    message.h = reader.float();
                    break;
                case /* float s */ 4:
                    message.s = reader.float();
                    break;
                case /* float v */ 5:
                    message.v = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Glyph, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string glyph = 2; */
        if (message.glyph !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.glyph);
        /* float h = 3; */
        if (message.h !== 0)
            writer.tag(3, WireType.Bit32).float(message.h);
        /* float s = 4; */
        if (message.s !== 0)
            writer.tag(4, WireType.Bit32).float(message.s);
        /* float v = 5; */
        if (message.v !== 0)
            writer.tag(5, WireType.Bit32).float(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Glyph
 */
export const Glyph = new Glyph$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Noun$Type extends MessageType<Noun> {
    constructor() {
        super("ninjamagic.Noun", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Noun>): Noun {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Noun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Noun): Noun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Noun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Noun
 */
export const Noun = new Noun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Health$Type extends MessageType<Health> {
    constructor() {
        super("ninjamagic.Health", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pct", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "stress_pct", kind: "scalar", localName: "stress_pct", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Health>): Health {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.pct = 0;
        message.stress_pct = 0;
        if (value !== undefined)
            reflectionMergePartial<Health>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Health): Health {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* float pct */ 2:
                    message.pct = reader.float();
                    break;
                case /* float stress_pct */ 3:
                    message.stress_pct = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Health, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* float pct = 2; */
        if (message.pct !== 0)
            writer.tag(2, WireType.Bit32).float(message.pct);
        /* float stress_pct = 3; */
        if (message.stress_pct !== 0)
            writer.tag(3, WireType.Bit32).float(message.stress_pct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Health
 */
export const Health = new Health$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stance$Type extends MessageType<Stance> {
    constructor() {
        super("ninjamagic.Stance", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Stance>): Stance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Stance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stance): Stance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Stance
 */
export const Stance = new Stance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Condition$Type extends MessageType<Condition> {
    constructor() {
        super("ninjamagic.Condition", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Condition>): Condition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Condition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Condition): Condition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Condition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Condition
 */
export const Condition = new Condition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Skill$Type extends MessageType<Skill> {
    constructor() {
        super("ninjamagic.Skill", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rank", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tnl", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "pending", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Skill>): Skill {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.rank = 0;
        message.tnl = 0;
        message.pending = 0;
        if (value !== undefined)
            reflectionMergePartial<Skill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Skill): Skill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 rank */ 2:
                    message.rank = reader.uint32();
                    break;
                case /* float tnl */ 3:
                    message.tnl = reader.float();
                    break;
                case /* float pending */ 4:
                    message.pending = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Skill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 rank = 2; */
        if (message.rank !== 0)
            writer.tag(2, WireType.Varint).uint32(message.rank);
        /* float tnl = 3; */
        if (message.tnl !== 0)
            writer.tag(3, WireType.Bit32).float(message.tnl);
        /* float pending = 4; */
        if (message.pending !== 0)
            writer.tag(4, WireType.Bit32).float(message.pending);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Skill
 */
export const Skill = new Skill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Datetime$Type extends MessageType<Datetime> {
    constructor() {
        super("ninjamagic.Datetime", [
            { no: 1, name: "seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Datetime>): Datetime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seconds = 0n;
        if (value !== undefined)
            reflectionMergePartial<Datetime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Datetime): Datetime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 seconds */ 1:
                    message.seconds = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Datetime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 seconds = 1; */
        if (message.seconds !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.seconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Datetime
 */
export const Datetime = new Datetime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Prompt$Type extends MessageType<Prompt> {
    constructor() {
        super("ninjamagic.Prompt", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Prompt>): Prompt {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Prompt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Prompt): Prompt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Prompt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Prompt
 */
export const Prompt = new Prompt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Kind$Type extends MessageType<Kind> {
    constructor() {
        super("ninjamagic.Kind", [
            { no: 1, name: "msg", kind: "message", oneof: "body", T: () => Msg },
            { no: 2, name: "pos", kind: "message", oneof: "body", T: () => Pos },
            { no: 3, name: "chip", kind: "message", oneof: "body", T: () => Chip },
            { no: 4, name: "tile", kind: "message", oneof: "body", T: () => Tile },
            { no: 5, name: "gas", kind: "message", oneof: "body", T: () => Gas },
            { no: 6, name: "glyph", kind: "message", oneof: "body", T: () => Glyph },
            { no: 7, name: "noun", kind: "message", oneof: "body", T: () => Noun },
            { no: 8, name: "health", kind: "message", oneof: "body", T: () => Health },
            { no: 9, name: "stance", kind: "message", oneof: "body", T: () => Stance },
            { no: 10, name: "condition", kind: "message", oneof: "body", T: () => Condition },
            { no: 11, name: "skill", kind: "message", oneof: "body", T: () => Skill },
            { no: 12, name: "datetime", kind: "message", oneof: "body", T: () => Datetime },
            { no: 13, name: "prompt", kind: "message", oneof: "body", T: () => Prompt }
        ]);
    }
    create(value?: PartialMessage<Kind>): Kind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.body = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Kind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Kind): Kind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ninjamagic.Msg msg */ 1:
                    message.body = {
                        oneofKind: "msg",
                        msg: Msg.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).msg)
                    };
                    break;
                case /* ninjamagic.Pos pos */ 2:
                    message.body = {
                        oneofKind: "pos",
                        pos: Pos.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).pos)
                    };
                    break;
                case /* ninjamagic.Chip chip */ 3:
                    message.body = {
                        oneofKind: "chip",
                        chip: Chip.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).chip)
                    };
                    break;
                case /* ninjamagic.Tile tile */ 4:
                    message.body = {
                        oneofKind: "tile",
                        tile: Tile.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).tile)
                    };
                    break;
                case /* ninjamagic.Gas gas */ 5:
                    message.body = {
                        oneofKind: "gas",
                        gas: Gas.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).gas)
                    };
                    break;
                case /* ninjamagic.Glyph glyph */ 6:
                    message.body = {
                        oneofKind: "glyph",
                        glyph: Glyph.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).glyph)
                    };
                    break;
                case /* ninjamagic.Noun noun */ 7:
                    message.body = {
                        oneofKind: "noun",
                        noun: Noun.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).noun)
                    };
                    break;
                case /* ninjamagic.Health health */ 8:
                    message.body = {
                        oneofKind: "health",
                        health: Health.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).health)
                    };
                    break;
                case /* ninjamagic.Stance stance */ 9:
                    message.body = {
                        oneofKind: "stance",
                        stance: Stance.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).stance)
                    };
                    break;
                case /* ninjamagic.Condition condition */ 10:
                    message.body = {
                        oneofKind: "condition",
                        condition: Condition.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).condition)
                    };
                    break;
                case /* ninjamagic.Skill skill */ 11:
                    message.body = {
                        oneofKind: "skill",
                        skill: Skill.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).skill)
                    };
                    break;
                case /* ninjamagic.Datetime datetime */ 12:
                    message.body = {
                        oneofKind: "datetime",
                        datetime: Datetime.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).datetime)
                    };
                    break;
                case /* ninjamagic.Prompt prompt */ 13:
                    message.body = {
                        oneofKind: "prompt",
                        prompt: Prompt.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).prompt)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Kind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ninjamagic.Msg msg = 1; */
        if (message.body.oneofKind === "msg")
            Msg.internalBinaryWrite(message.body.msg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Pos pos = 2; */
        if (message.body.oneofKind === "pos")
            Pos.internalBinaryWrite(message.body.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Chip chip = 3; */
        if (message.body.oneofKind === "chip")
            Chip.internalBinaryWrite(message.body.chip, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Tile tile = 4; */
        if (message.body.oneofKind === "tile")
            Tile.internalBinaryWrite(message.body.tile, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Gas gas = 5; */
        if (message.body.oneofKind === "gas")
            Gas.internalBinaryWrite(message.body.gas, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Glyph glyph = 6; */
        if (message.body.oneofKind === "glyph")
            Glyph.internalBinaryWrite(message.body.glyph, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Noun noun = 7; */
        if (message.body.oneofKind === "noun")
            Noun.internalBinaryWrite(message.body.noun, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Health health = 8; */
        if (message.body.oneofKind === "health")
            Health.internalBinaryWrite(message.body.health, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Stance stance = 9; */
        if (message.body.oneofKind === "stance")
            Stance.internalBinaryWrite(message.body.stance, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Condition condition = 10; */
        if (message.body.oneofKind === "condition")
            Condition.internalBinaryWrite(message.body.condition, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Skill skill = 11; */
        if (message.body.oneofKind === "skill")
            Skill.internalBinaryWrite(message.body.skill, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Datetime datetime = 12; */
        if (message.body.oneofKind === "datetime")
            Datetime.internalBinaryWrite(message.body.datetime, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* ninjamagic.Prompt prompt = 13; */
        if (message.body.oneofKind === "prompt")
            Prompt.internalBinaryWrite(message.body.prompt, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Kind
 */
export const Kind = new Kind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Packet$Type extends MessageType<Packet> {
    constructor() {
        super("ninjamagic.Packet", [
            { no: 1, name: "envelope", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Kind }
        ]);
    }
    create(value?: PartialMessage<Packet>): Packet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.envelope = [];
        if (value !== undefined)
            reflectionMergePartial<Packet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Packet): Packet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ninjamagic.Kind envelope */ 1:
                    message.envelope.push(Kind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Packet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ninjamagic.Kind envelope = 1; */
        for (let i = 0; i < message.envelope.length; i++)
            Kind.internalBinaryWrite(message.envelope[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ninjamagic.Packet
 */
export const Packet = new Packet$Type();
